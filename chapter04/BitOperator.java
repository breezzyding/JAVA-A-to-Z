//位运算

public class BitOperator {

	//编写一个main方法
	public static void main(String[] args) {

		//推导过程
		//1.得到2的补码 => 2的原码 00000000 00000000 00000000 00000010
		//	2的补码 00000000 00000000 00000000 00000010（三码合一）
		//2.得到3的补码=3的原码00000000 00000000 00000000 00000011
		//3.按位与&
		//	00000000 00000000 00000000 00000010
		//	00000000 00000000 00000000 00000011
		//	00000000 00000000 00000000 00000010 & 运算后的补码
		//	0（正数）0000000 00000000 00000000 00000010 运算后的原码
		//	结果是2
		System.out.println(2 & 3);//2

		//推导过程
		//1.得到-2的原码 1(负数)0000000 00000000 00000000 00000010
		//	-2的反码 11111111 11111111 11111111 11111101
		//2.-2的补码=-2的反码 + 1
		//	11111111 11111111 11111111 11111110
		//3.~的操作
		//	00000000 00000000 00000000 00000001  ~运算后的补码
		//	0（正数）0000000 00000000 00000000 00000001 运算后的原码
		//	结果是1		
		System.out.println(~ -2);//1
		
		//推导过程
		//1.得到2的补码 00000000 00000000 00000000 00000010（三码合一）
		//2.~-2的操作
		//	11111111 11111111 11111111 11111101 ~运算后的补码
		//	11111111 11111111 11111111 11111100 ~运算后的反码
		//	10000000 00000000 00000000 00000011	~运算后的原码
		//	结果是-3
		System.out.println(~ 2);//-3

		//推导过程
		//1.得到2的补码 00000000 00000000 00000000 00000010(三码合一)
		//2.得到3的补码 00000000 00000000 00000000 00000011(三码合一)
		//3.2 | 3的操作
		//	00000000 00000000 00000000 00000010 2的补码
		//	00000000 00000000 00000000 00000011 3的补码
		//	00000000 00000000 00000000 00000011	| 运算后的补码
		//	00000000 00000000 00000000 00000011	| 运算后的原码(三码合一)
		//	结果是3
		System.out.println(2 | 3);//3

		//推导过程
		//1.得到-5的原码 1(负数)0000000 00000000 00000000 00000101
		//	-5的反码 11111111 11111111 11111111 11111010(符号位不变)
		//2.-5的补码=-5的反码 + 1
		//	11111111 11111111 11111111 11111011
		//3.~的操作
		//	00000000 00000000 00000000 00000100  ~运算后的补码
		//	0（正数）0000000 00000000 00000000 00000001 运算后的原码
		//	结果是4	
		System.out.println(~ -5);//4

		//推导过程
		//1.13的补码 00000000 00000000 00000000 00001101(三码合一)
		//2.7的补码 00000000 00000000 00000000 00000111(三码合一)
		//3.按位与&
		//	00000000 00000000 00000000 00001101
		//	00000000 00000000 00000000 00000111
		//	00000000 00000000 00000000 00000101 & 运算后的补码(三码合一)
		//	结果是5
		System.out.println(13 & 7);//5

		//推导过程
		//1.得到5的补码 00000000 00000000 00000000 00000101(三码合一)
		//2.得到4的补码 00000000 00000000 00000000 00000100(三码合一)
		//3.5 | 4的操作
		//	00000000 00000000 00000000 00000101 5的补码
		//	00000000 00000000 00000000 00000100 4的补码
		//	00000000 00000000 00000000 00000101	| 运算后的补码(三码合一)
		//	结果是5
		System.out.println(5 | 4);//5

		//推导过程
		//1.得到-3的原码 10000000 00000000 00000000 00000011
		//2.得到-3的反码 11111111 11111111 11111111 11111100
		//3.得到-3的补码 11111111 11111111 11111111 11111101
		//2.得到3的补码 00000000 00000000 00000000 00000011(三码合一)
		//3.-3 ^ 3的操作
		//	11111111 11111111 11111111 11111101 -3的补码
		//	00000000 00000000 00000000 00000011 3的补码
		//	11111111 11111111 11111111 11111110	^ 运算后的补码
		//	11111111 11111111 11111111 11111101 ^ 运算后的反码
		//	10000000 00000000 00000000 00000010 ^ 运算后的原码
		//	结果是-2
		System.out.println(-3 ^ 3);//-2


		int a = 1>>2;//1向右移2位
		// 1 => 0000 0001 => 0000 0000
		// 本质1 / 2 / 2 = 0
		
		int b = -1>>2;
		// -1的原码 	1000 0001
		// -1的反码 	1111 1110
		// -1的原码 	1111 1111
		// 右移两位 	1111 1100 (低位溢出，符号位不变，高位补符号位)
		// 求其反码 	1111 1011 (符号位不变)
		// 求其原码 	1000 0100
		// 结果-4

		int c = 1<<2;
		//1 => 0000 0001 => 0000 0100
		//本质 1 * 2 * 2 = 4

		int d = -1<<2;
		// -1的原码 	1000 0001
		// -1的反码 	1111 1110
		// -1的原码 	1111 1111
		// 左移两位 	1111 1111 (低位溢出，符号位不变，高位补符号位)
		// 求其反码 	1111 1110 (符号位不变)
		// 求其原码 	1000 0001
		// 结果-1
		
		int e = 3>>>2;//无符号右移
		//3 => 0000 0011 => 0000 0000
		//本质 3 / 2 / 2 / 2 = 0
		
		System.out.println("a=" + a);//0
		System.out.println("b=" + b);//-1
		System.out.println("c=" + c);//4
		System.out.println("d=" + d);//-4
		System.out.println("e=" + e);//0
	}
}
