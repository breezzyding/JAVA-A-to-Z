package com.dinglearn.codeblock_;

/**
 * 注意事项和细节讨论
 * 1.static代码块叫静态代码块,作用就是对类进行初始化,而且它随着类的加载而执行
 *   并且只会执行一次,如果是普通代码块,每创建一个对象,就执行
 * 2.类什么时候被加载
 *   1)创建对象实例时(new)
 *   2)创建子类对象实例,父类也会被加载
 *   3)使用类的静态成员时(静态属性 静态方法)
 * 3.普通的代码块,在创建对象实例时,对被隐式的调用,被创建一次,就会调用一次
 *   如果只是使用类的静态成员时,普通代码块不会执行
 * 4.创建一个对象时,在一个类调用顺序是 (重点 难点)
 *   1)调用静态代码块和静态属性初始化(注意:静态代码块和静态属性初始化调用的优先级一样
 *   如果有多个静态代码块和多个静态变量初始化,则按他们定义的顺序调用)
 *   2)调用普通代码块和普通属性的初始化(注意:普通代码块和普通属性初始化调用的优先级一样
 *   如果有多个普通代码块和多个普通属性初始化,则按定义顺序调用)
 *   3)调用构造器
 * 5.构造器的最前面其实隐含了super()和调用普通代码块,新写一个类演示
 *   静态相关的代码块,属性初始化,在类加载时,就执行完毕,因此是优先于构造器和普通代码块执行的
 * 6.静态代码块 静态初始化 普通代码块 普通属性初始化 构造方法 的调用顺序
 *   1)父类的静态代码块和静态属性(优先级一样,按定义顺序执行)
 *   2)子类的静态代码块和静态属性(优先级一样,按定义顺序执行)
 *   3)父类的普通代码块和普通属性初始化(优先级一样,按定义顺序执行)
 *   4)父类的构造方法
 *   5)子类的普通代码块和普通属性初始化(优先级一样,按定义顺序执行)
 *   6)子类的构造方法
 * 7.静态代码块只能直接调用静态成员(静态属性和静态方法),普通代码块可以调用任意成员
 *
 *
 */

public class CodeBlockDetail01 {
    public static void main(String[] args) {

        //类什么时候被加载
        //1.创建对象实例时(new)
        //AA aa1 = new AA();

        //2.创建子类对象实例,父类也会被加载
        //  而且父类先被加载,子类后被加载
        //AA aa2 = new AA();

        //3.使用类的静态成员时(静态属性 静态方法)
        //System.out.println(Cat.n1);

        //static代码块,是在类加载时,执行的,而且只会执行一次
//        DD dd = new DD();
//        DD dd1 = new DD();

        //普通的代码块,在创建对象实例时,对被隐式的调用,被创建一次,就会调用一次
        //如果只是使用类的静态成员时,普通代码块不会执行
        System.out.println(DD.n1);

    }
}

class DD {
    public static int n1 = 8888;//静态属性
    //静态代码块
    static  {
        System.out.println("DD 的静态代码块1被执行");
    }
    {
        System.out.println("DD 的普通代码块被执行...");
    }
}

class Animal {
    //静态代码块
    static  {
        System.out.println("Animal 的静态代码块1被执行");
    }
}

class Cat extends Animal {

    public static int n1 = 999;

    //静态代码块
    static  {
        System.out.println("Cat 的静态代码块1被执行");
    }
}

class BB {

    //静态代码块
    static {
        System.out.println("BB 的静态代码块1被执行");
    }
}

class AA extends BB {

    //静态代码块
    static {
        System.out.println("AA 的静态代码块1被执行");
    }
}


